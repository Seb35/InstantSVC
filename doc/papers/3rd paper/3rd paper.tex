%% 3rd paper.tex
%% V1.0
%% March 10, 2006
%% by Stefan Marr, Falko Menge, Gregor Gabrysiak, Martin Sprengel, 
%%    Christoph Hartmann, Michael Perscheid, Andreas Meyer and Sebastian Böttner
%%
%% NOTE: This text file uses UNIX line feed conventions. When (human)
%% reading this file on other platforms, you may have to use a text
%% editor that can handle lines terminated by the UNIX line feed
%% character (0x0A).
%%
%% requires IEEEtran.cls version 1.6b or later
%%
%% Support sites:
%% http://www.ieee.org
%% and/or
%% http://www.ctan.org/tex-archive/macros/latex/contrib/supported/IEEEtran/
%%

% Also note that the "draftcls" or "draftclsnofoot", not "draft", option
% should be used if it is desired that the figures are to be displayed in
% draft mode.
%
% This example can be formatted using the peerreview
% (instead of journal) mode.
\documentclass[journal,a4paper,twoside,10pt]{IEEEtran}
% If the IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it:
% \documentclass[journal]{../sty/IEEEtran}


% deutsche Sonderzeichen benutzen
%\usepackage[ngerman]{babel}
\usepackage{ngerman}

% Unterstützung für deutsche Umlaute
\usepackage[ansinew]{inputenc}

% EC-Fonts verwenden (Fonts, in denen - im Gegensatz zu den CM-Fonts - die Umlaute als eigene Zeichen existieren, so daß diese nicht aus mehreren Zeichen zusammengesetzt werden müssen)
\usepackage[T1]{fontenc}

% some very useful LaTeX packages include:

\usepackage{cite}      % Written by Donald Arseneau
                        % V1.6 and later of IEEEtran pre-defines the format
                        % of the cite.sty package \cite{} output to follow
                        % that of IEEE. Loading the cite package will
                        % result in citation numbers being automatically
                        % sorted and properly "ranged". i.e.,
                        % [1], [9], [2], [7], [5], [6]
                        % (without using cite.sty)
                        % will become:
                        % [1], [2], [5]--[7], [9] (using cite.sty)
                        % cite.sty's \cite will automatically add leading
                        % space, if needed. Use cite.sty's noadjust option
                        % (cite.sty V3.8 and later) if you want to turn this
                        % off. cite.sty is already installed on most LaTeX
                        % systems. The latest version can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/supported/cite/

\usepackage{graphicx}  % Written by David Carlisle and Sebastian Rahtz
                        % Required if you want graphics, photos, etc.
                        % graphicx.sty is already installed on most LaTeX
                        % systems. The latest version and documentation can
                        % be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/required/graphics/
                        % Another good source of documentation is "Using
                        % Imported Graphics in LaTeX2e" by Keith Reckdahl
                        % which can be found as esplatex.ps and epslatex.pdf
                        % at: http://www.ctan.org/tex-archive/info/
% NOTE: for dual use with latex and pdflatex, instead load graphicx like:
%\ifx\pdfoutput\undefined
%\usepackage{graphicx}
%\else
%\usepackage[pdftex]{graphicx}
%\fi

% However, be warned that pdflatex will require graphics to be in PDF
% (not EPS) format and will preclude the use of PostScript based LaTeX
% packages such as psfrag.sty and pstricks.sty. IEEE conferences typically
% allow PDF graphics (and hence pdfLaTeX). However, IEEE journals do not
% (yet) allow image formats other than EPS or TIFF. Therefore, authors of
% journal papers should use traditional LaTeX with EPS graphics.
%
% The path(s) to the graphics files can also be declared: e.g.,
% \graphicspath{{../eps/}{../ps/}}
% if the graphics files are not located in the same directory as the
% .tex file. This can be done in each branch of the conditional above
% (after graphicx is loaded) to handle the EPS and PDF cases separately.
% In this way, full path information will not have to be specified in
% each \includegraphics command.
%
% Note that, when switching from latex to pdflatex and vice-versa, the new
% compiler will have to be run twice to clear some warnings.


%\usepackage{psfrag}    % Written by Craig Barratt, Michael C. Grant,
                        % and David Carlisle
                        % This package allows you to substitute LaTeX
                        % commands for text in imported EPS graphic files.
                        % In this way, LaTeX symbols can be placed into
                        % graphics that have been generated by other
                        % applications. You must use latex->dvips->ps2pdf
                        % workflow (not direct pdf output from pdflatex) if
                        % you wish to use this capability because it works
                        % via some PostScript tricks. Alternatively, the
                        % graphics could be processed as separate files via
                        % psfrag and dvips, then converted to PDF for
                        % inclusion in the main file which uses pdflatex.
                        % Docs are in "The PSfrag System" by Michael C. Grant
                        % and David Carlisle. There is also some information 
                        % about using psfrag in "Using Imported Graphics in
                        % LaTeX2e" by Keith Reckdahl which documents the
                        % graphicx package (see above). The psfrag package
                        % and documentation can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/supported/psfrag/

%\usepackage{subfigure} % Written by Steven Douglas Cochran
                        % This package makes it easy to put subfigures
                        % in your figures. i.e., "figure 1a and 1b"
                        % Docs are in "Using Imported Graphics in LaTeX2e"
                        % by Keith Reckdahl which also documents the graphicx
                        % package (see above). subfigure.sty is already
                        % installed on most LaTeX systems. The latest version
                        % and documentation can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/supported/subfigure/

%\usepackage{url}       % Written by Donald Arseneau
                        % Provides better support for handling and breaking
                        % URLs. url.sty is already installed on most LaTeX
                        % systems. The latest version can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/other/misc/
                        % Read the url.sty source comments for usage information.

%\usepackage{stfloats}  % Written by Sigitas Tolusis
                        % Gives LaTeX2e the ability to do double column
                        % floats at the bottom of the page as well as the top.
                        % (e.g., "\begin{figure*}[!b]" is not normally
                        % possible in LaTeX2e). This is an invasive package
                        % which rewrites many portions of the LaTeX2e output
                        % routines. It may not work with other packages that
                        % modify the LaTeX2e output routine and/or with other
                        % versions of LaTeX. The latest version and
                        % documentation can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/supported/sttools/
                        % Documentation is contained in the stfloats.sty
                        % comments as well as in the presfull.pdf file.
                        % Do not use the stfloats baselinefloat ability as
                        % IEEE does not allow \baselineskip to stretch.
                        % Authors submitting work to the IEEE should note
                        % that IEEE rarely uses double column equations and
                        % that authors should try to avoid such use.
                        % Do not be tempted to use the cuted.sty or
                        % midfloat.sty package (by the same author) as IEEE
                        % does not format its papers in such ways.

%\usepackage{amsmath}   % From the American Mathematical Society
                        % A popular package that provides many helpful commands
                        % for dealing with mathematics. Note that the AMSmath
                        % package sets \interdisplaylinepenalty to 10000 thus
                        % preventing page breaks from occurring within multiline
                        % equations. Use:
%\interdisplaylinepenalty=2500
                        % after loading amsmath to restore such page breaks
                        % as IEEEtran.cls normally does. amsmath.sty is already
                        % installed on most LaTeX systems. The latest version
                        % and documentation can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/



% Other popular packages for formatting tables and equations include:

%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty which improves the
% LaTeX2e array and tabular environments to provide better appearances and
% additional user controls. array.sty is already installed on most systems.
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/

% Mark Wooding's extremely powerful MDW tools, especially mdwmath.sty and
% mdwtab.sty which are used to format equations and tables, respectively.
% The MDWtools set is already installed on most LaTeX systems. The lastest
% version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/supported/mdwtools/


% V1.6 of IEEEtran contains the IEEEeqnarray family of commands that can
% be used to generate multiline equations as well as matrices, tables, etc.


% Also of notable interest:

% Scott Pakin's eqparbox package for creating (automatically sized) equal
% width boxes. Available:
% http://www.ctan.org/tex-archive/macros/latex/contrib/supported/eqparbox/



% Notes on hyperref:
% IEEEtran.cls attempts to be compliant with the hyperref package, written
% by Heiko Oberdiek and Sebastian Rahtz, which provides hyperlinks within
% a document as well as an index for PDF files (produced via pdflatex).
% However, it is a tad difficult to properly interface LaTeX classes and
% packages with this (necessarily) complex and invasive package. It is
% recommended that hyperref not be used for work that is to be submitted
% to the IEEE. Users who wish to use hyperref *must* ensure that their
% hyperref version is 6.72u or later *and* IEEEtran.cls is version 1.6b
% or later. The latest version of hyperref can be obtained at:
%
% http://www.ctan.org/tex-archive/macros/latex/contrib/supported/hyperref/
%
% Also, be aware that cite.sty (as of version 3.9, 11/2001) and hyperref.sty
% (as of version 6.72t, 2002/07/25) do not work optimally together.
% To mediate the differences between these two packages, IEEEtran.cls, as
% of v1.6b, predefines a command that fools hyperref into thinking that
% the natbib package is being used - causing it not to modify the existing
% citation commands, and allowing cite.sty to operate as normal. However,
% as a result, citation numbers will not be hyperlinked. Another side effect
% of this approach is that the natbib.sty package will not properly load
% under IEEEtran.cls. However, current versions of natbib are not capable
% of compressing and sorting citation numbers in IEEE's style - so this
% should not be an issue. If, for some strange reason, the user wants to
% load natbib.sty under IEEEtran.cls, the following code must be placed
% before natbib.sty can be loaded:
%
% \makeatletter
% \let\NAT@parse\undefined
% \makeatother
%
% Hyperref should be loaded differently depending on whether pdflatex
% or traditional latex is being used:
%
%\ifx\pdfoutput\undefined
%\usepackage[hypertex]{hyperref}
%\else
%\usepackage[pdftex,hypertexnames=false]{hyperref}
%\fi
%
% Pdflatex produces superior hyperref results and is the recommended
% compiler for such use.



% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.


% correct bad hyphenation here
%\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
%
% paper title
\title{Web Service Toolkit für PHP5}
%
\author{
\begin{center}
Stefan~Marr, Falko~Menge, Gregor~Gabrysiak, Martin~Sprengel, Michael~Perscheid,
\end{center}
Christoph~Hartmann, Andreas~Meyer und Sebastian~Böttner
%\begin{center}
%\textit{Seminar Konzepte und Methoden der Web-Programmierung 2005/2006}
%\end{center}
%\begin{center}
%Hasso-Plattner-Institut für Softwaresystemtechnik
%\end{center}
}% <-this % stops a space
% 
% The paper headers
\markboth{Seminar Konzepte und Methoden der Web-Programmierung 2005/2006}{Web Service Toolkit für PHP5}
% The only time the second header will appear is for the odd numbered pages
% after the title page when using the twoside option.
% 
% *** Note that you probably will NOT want to include the author's name in ***
% *** the headers of peer review papers.                                   ***

% If you want to put a publisher's ID mark on the page
% (can leave text blank if you just want to see how the
% text height on the first page will be reduced by IEEE)
%\pubid{0000--0000/00\$00.00~\copyright~2002 IEEE}

% use only for invited papers
%\specialpapernotice{(Invited Paper)}

% make the title area
\maketitle

\begin{abstract}

Dieses Paper beschreibt die Ergebnisse unserer Arbeit an einer Familie von Werkzeugen für Web Services unter PHP5. Allerdings machen die besonderen Spracheigenschaften die Entwicklung von Meta-Spach-Werkzeugen etwas schwiereig. Daher wurde zunächst die Reflection API erweitert um die benötigten Informationen über Sprachkonstrukte zu bekommen. Auf dieser Basis wurde zunächst ein leistungsfähiger WSDL-Generator...
\end{abstract}

\begin{keywords}
PHP5, Reflection, Annotations, Web Services, WSDL-Generator, SOAP-Handler-Chains, WS-Security, REST.
\end{keywords}
% Note that keywords are not normally used for peerreview papers.

% For peer review papers, you can put extra information on the cover
% page as needed:
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
%
% For peerreview papers, inserts a page break and creates the second title.
% Will be ignored for other modes.
\IEEEpeerreviewmaketitle

%Gliederung Paper (Obergrenze 10 S.)
%1.Intension/Aufgabenstellung (Falko)
%2.Reflection-API (Stefan)
%a.Architektur
%3.WSDL-Generator (Gregor, Falko)
%4.Sicherheit (Michael, Christoph)
%5.Tools (Architektur/Verweis auf Paper 2) (Martin)
%6.Beispiel-Anwendung (Sebastian, Andreas)
%
%
%Grundsätzliche Teilung der Ausarbeitung
%1.Paper
%a.Überblick, Motivation
%b.Archtitektur und Technicken/Standards
%2.Anhang
%a.Sourcecode Doku
%b.Tutorial
%Tutorials
%i.Reflection API
%ii.Admin Tool (Martin)
%iii.Generator
%iv.REST-Server (Stefan)
%v.Vollständiger Durchgang (von A-Z) (Andreas, Sebastian)


\section{Einführung}

\PARstart{W}{eb Services} sind eines der wichtigsten IT-Themen der letzten Jahre. Sie bieten interoperable Kommunikation über Plattform- und Programmiersprachengrenzen hinweg und stellen aus diesem Grund für Unternehmen ein vielversprechendes Konzept dar. Web Services werden eingesetzt um bestehende interne und unternehmensübergreifende Anwendungen sinnvoll zu integrieren und so Geschäftsprozesse zu optimieren. Das Grundprinzip dabei ist, dass Anwendungen ihre Funktionalität in Form von Diensten anbieten, die über das Internet von anderen Anwendungen genutzt werden können.

Die wichtigsten Grundlagenstandards für Web Services sind das \textit{SOAP-Protokoll} \cite{SOAP}, die \textit{Web Services Description Language (WSDL)} \cite{WSDL} und \textit{Universal Description, Discovery and Integration (UDDI)} \cite{UDDI}. SOAP ist dabei das Kommunikationsprotokoll für den Zugriff auf die Dienste. Mit WSDL werden vertragsähnliche Beschreibungsdokumente erstellt, die ein Anbieter den Nutzern zur Verfügung stellen kann. UDDI ist der Standard für Namensdienste, mit denen Web Services bekannt gemacht und gesucht werden können.

Zur effektiven und interoperablen Nutzung von SOAP und, mit Abstrichen, von WSDL existieren für alle üblichen Programmiersprachen und Plattformen  voll ausgereifte Werkzeuge, die für den Produktionsbetrieb eingesetzt werden können. Für UDDI Namensdienste werden meist kommerzielle Produkte verwendet, die via Web Service in die Anwendungen integriert werden.

In unserer ersten Ausarbeitung \textit{"`Einführung in XML Web Services"'} \cite{WebServicePart1} haben wir SOAP, WSDL und UDDI vorgestellt und gezeigt, wie man die Standards mit PHP5 nutzen kann. PHP5 bietet eine Implementierung des SOAP-Protokolls, die sich nutzen lässt, um interoperable SOAP-Server und -Clients zu entwickeln.

Um eine Klasse in PHP5 als Web Service anzubieten, erstellt man zunächst eine Beschreibung der Schnittstelle mit WSDL. Dabei definiert man unter anderem für alle Datentypen mit Hilfe von XML~Schema-Ausdrücken, wie sie für das Versenden in SOAP-Nachrichten serialisiert werden sollen. Eine Dokumentation der Methodensemantik kann manuell aus dem Quelltext der Klasse in die Schnittstellen-Beschreibung übertragen werden. Danach schreibt man ein PHP Script, das mit Hilfe der WSDL-Beschreibung einen SOAP Server startet. Dieser erzeugt dann ein Exemplar der dazugehörigen Klasse und beginnt SOAP-Anfragen zu beantworten.

Das ist natürlich bei weitem nicht so komfortabel, wie man es von .NET oder Java~EE gewohnt ist. Zwar ist die SOAP-Implementierung sehr einfach zu benutzen, aber die manuelle Erstellung von WSDL-Beschreibungen ist sehr aufwändig und könnte prinzipiell automatisiert werden. Um also professionell in großen Systemen Web Services anzubieten benötigt man umfangreiche Werkzeugunterstützung. Typischerweise verwendet man in anderen Programmiersprachen Annotationsmechanismen um Klassen und Methoden einer Anwendung zu markieren, die als Web Service verwendet werden sollen. Mit dem so markierten Quelltext wird eine Werkzeugkette angestoßen, die dann WSDL-Beschreibungen, zusätzlichen Code für Stubs und Skeletons und falls nötig Deployment-Deskriptoren generiert, mit denen die Web Services sofort bereit für den Produktiveinsatz sind.

Das Ziel unserer Arbeit war es, die Lücken in der Werkzeugunterstützung für PHP5 zu schließen.


\section{Extended Reflection API}
Die in PHP5 integrierte Reflection API bietet die grundlegenden Möglichkeiten,
um zur Laufzeit Informationen zur Struktur der verfügbaren programmiersprachlichen Konstrukte,
insbesondere der verfügbaren Klassen, Erweiterungen und Funktionen, zu erhalten.
Darüber hinaus bietet sie ebenso die Möglichkeit auf Exemplare dieser Konstrukte zuzugreifen,
um den aktuellen Zustand zur Laufzeit zu ermitteln oder zu modifizieren.
\begin{figure}[!htb]
\centering
\includegraphics[width=3.4in]{reflection-api/webp-reflection-api}
\caption{UML-Darstellung der PHP5 Reflection API}
\label{ref_api}
\end{figure}

In Abb. \ref{ref_api} ist die grobe Struktur der API dargestellt,
welche einem Metamodel für die Definition einer Klasse im Sinne 
der objektorientierten Programmierung entspricht. 
Da PHP5 selbst eine schwach typisierte und teils sogar dynamische Sprache ist, 
bietet die API nur sehr wenige Informationen zur Typisierung der einzelnen Sprachkonstrukte an. 
Um jedoch nicht nur zur Laufzeit Informationen über die Typisierung erhalten zu können, 
wurde es erforderlich, die vorhandene API zu erweitern. Ziel dieser Erweiterung ist es, 
zusätzliche Informationen in der Kommentierung der Sprachkonstrukte nutzen zu können. 
Dabei wurde auf PHPDoc, eine in der PHP-Welt verbreitete Variation des JavaDoc-Standards, gesetzt. 
Ursprünglich waren diese Informationen dazu gedacht, dem Entwickler unter die Arme zu greifen, 
in dem der Quellcode durch zusätzliche Informationen angereichert wird.

Da die PHPDoc-Tags in der PHP-Welt überwiegend als Standard akzeptiert sind 
und in viele bestehenden Projekten von diesen Gebrauch gemacht wird, 
bieten sie eine gute Basis um die nötigen Informationen aus den Quelltext-Kommentaren zu extrahieren, 
ohne auf neue Verfahren zurückzugreifen, die bei einem Nutzer weitgehende Anpassungen erfordern würden.

Die erweiterte Reflection API nutzt zur Gewinnung der Typinformationen 
einen einfachen PHPDoc-Parser, welcher die Quellcode-Kommentare 
untersucht und interpretiert. Um diese Informationen geeignet nutzen zu können, 
wurde eine programmiersprachliche Repräsentation für ein einfaches Typensystem entworfen.
\begin{figure}[!htb]
\centering
\includegraphics[width=3.4in]{reflection-api/webp-extreflection-api}
\caption{UML-Darstellung der erweiterten Reflection API}
\label{extref_api}
\end{figure}

In Abb. \ref{extref_api} ist das zentrale Interface \texttt{Type} dargestellt. Dieses wird letztendlich 
von drei wesentlichen Klassen implementiert. \texttt{ClassType} repräsentiert alle 
Klassen, \textsl{ArrayType} alle möglichen Array-Typen und \texttt{PrimitiveType} die einfachen Datentypen 
wie \texttt{Integer}, \texttt{Float} und \texttt{String}. Damit ist es möglich aus einem programmiersprachlichen 
Konstrukt, nicht nur zur eigenen Laufzeit, sondern auch ohne ein Exemplar 
des Konstrukts, die gewünschten Typeninformationen zu gewinnen.

Dieses Typensystem erlaut zusätzlich vielfältige eigene Erweiterungen. 
Durch die Verwendung einer \texttt{TypeFactory} ist es möglich für verschiedene 
Anwendungsaspekte angepasste Typenklassen zu entwickeln, die weitere 
Zusatzinformationen zur Verfügung stellen. Aktuell implementiert ist 
unter anderem die Möglichkeit, direkt aus den Typen ihre Definition 
in XML-Schema zu erhalten, um Exemplare so ohne Umwege nach XML serialisieren zu können.

Eine weitere wesentliche Erweiterung ist die Implementierung eines Annotation-Mechanismus,
% das muss Genitiv sein, aber Mechanismusses hört sich komsich an und ich hab grad keinen Duden um nachzuschauen
 welcher in PHP bis dahin nicht verfügbar war, sich jedoch in anderen gängigen Programmiersprachen zunehmender Beliebtheit erfreut. Für dieses Projekt stand
% nicht "steht" ?
 die statische Verwendung von Zusatzinformationen im Vordergrund. So ist es möglich die programmiersprachlichen Konstrukte mit zusätzlichen Eigenschaften zu versehen, unter anderem die Kennzeichnung als Web Service. Zusätzlich denkbar wäre es, diesen Annotation-Mechanismus durch eine geeignete Laufzeitumgebung zu nutzen, um aspektorientierte Programmierung unterstützen zu können. Dies ist in diesem Projekt jedoch nicht realisiert.

\section{WSDL Generator}
Um einen Web Service anzubieten, muss man ihn passend beschreiben, 
denn nur so erfahren Clients, wie er zu benutzen ist. Dazu gibt 
es die Web Service Description Language (WSDL), welche unter 
\cite{WebServicePart1} näher erläutert wird. Der WSDL-Generator erzeugt die
WSDL-Dateien gemäß dem WSDL 1.1 Standard\cite{WSDL}.

Bereits bei der Konzeption eines Web Services gibt es zwei 
grundlegende Entscheidungen zu treffen: die Art des Methodenaufrufs 
und die Art der Datenrepräsentation in XML. Zuerst widmen wir uns den Aufrufsmodi.

Ein Web Service kann durch zwei verschiedene Arten angestoßen 
werden - entweder über einen 
"`Remote-Procedure-Call"' (RPC) oder auf Basis des "`document"'-Stils (DOC).
Bei RPC wird versucht, durch die Methode und deren Parameter 
einen Methodenaufrufsstack direkt beim Server nachzuahmen. 
Die so aufgebaute Struktur, die diesen Stack repräsentiert, 
wird dann zur Kommunikation genutzt. Der Client nimmt den 
Web Service als einzelne, logische Komponente mit gekapselten 
Objekten wahr. Die  Komplexität wird also durch den SOAP RPC Stack verborgen.

Bei der DOC-Variante hingegen wird der Methodenaufruf direkt auf 
einen XML-Schema abgebildet. Der gesamte Nachrichtenaustausch 
zwischen Client und Web Service ist hier durch die zugrunde 
liegende Web Service-Beschreibung bereits vorgegeben. 
Demzufolge muss nur die Nachricht benannt werden um die Parameterliste 
direkt übergeben zu können, da die Nachricht deren Art und Reihenfolge 
bereits vorgibt. Dadurch entsteht bei der Kommunikation viel weniger 
Traffic, als es bei RPC der Fall ist. Während nämlich die Methodenaufrufe 
durch den Aufbau des Stacks erheblich mehr Overhead erzeugen, muss man 
bei DOC nur die Nachricht aus dem Schema identifizieren und kann die 
(benannten) Parameter direkt übergeben. Eine genauere Darstellung der 
Auswirkungen der verschiedenen SOAP Varianten auf die Performance ist 
unter \cite{ibm:soapenc} zu finden.

%Stefan: hier ist nicht erklärt, was Encoded und was Literal den wirklich sind
Des Weiteren gibt es noch zwei verschiedene Kodierungsmöglichkeiten, 
um die Übergabewerte beim Sender zu serialisieren und beim Empfänger 
wieder zu rekonstruieren. Die erste Variante ist der SOAP-Encoded-Standard.
Dieser schreibt vor, dass jeder Parameter, der zu einer Nachricht gehört,
einen abstrakten, vom Standard definierten Typen angibt. Wenn die Nachricht 
dann also versendet werden soll, können Client und Web Service dafür sorgen,
die so typisierten Parameter zu nutzen.
Die zweite Kodierungsart ist die "`Literal"'-Variante. Hierbei wird für die
Beschreibung der Parameter ein Schema benutzt. Normalerweise werden die 
primitiven Datentypen durch die Einbindung eines entsprechenden Schemas 
bereits definiert, doch alle komplexeren Datentypen müssen explizit
beschrieben werden.

Diese zwei mal zwei Möglichkeiten lassen sich nun kombinieren und 
so ergeben sich theoretisch vier Varianten, einen Web Service zu erstellen:
 	
\begin{itemize}
	\item RPC/Encoded
 	\item RPC/Literal
 	\item Document/Encoded
 	\item Document/Literal
\end{itemize}

Document/Encoded wird jedoch nicht genutzt, da es sich schon 
in seiner Konzeption selbst widerspricht. 
Die Frage bleibt also: welche Kombination ist zu bevorzugen?
Die Antwort liefert ein Industriekonsortium namens WS-I, 
das sich mit der plattformübergreifenden Kommunikation zwischen 
Web Services beschäftigt. Daher werden Web Services, die interoperabel
zusammenarbeiten können, als WS-I-konform bezeichnet. Das ist 
jedoch nur solchen Web Services vorenthalten, die auf den 
Kombinationen RPC/Literal oder Document/Literal aufbauen. 
Daher wurde bei der Entwicklung des WSDL-Generators der Fokus in 
erster Linie auf die Kodierungsart Literal gesetzt. Trotzdem ist 
er in der Lage, neben den WS-I-konformen Varianten auch das 
dennoch gebräuchliche RPC/Encoded durch die Erzeugung entsprechender 
WSDL-Dateien zu unterstützen.

Der WSDL-Generator selbst wird initialisiert mit der Angabe des Namens 
des zu erstellenden Services, mit dem URI über den der Service 
erreichbar sein soll, außerdem mit seinem Namespace und der 
gewünschten Aufrufs-/Zugriffskombination. Standardmäßig wird vom 
Generator die "`Document/Literal-Wrapped"'-Kombination genutzt.
Der Entwickler kann dann entweder per \texttt{setClass()} eine Klasse, 
deren Funktionalität angeboten werden soll, einlesen lassen oder per 
\texttt{addFunction()} eine beliebige Menge von Methoden zur Erbringung 
dieser Funktionalität nutzen. Es ist jedoch nicht möglich, diese beiden 
Methoden der Erstellung zu mischen, da sie sich gegenseitig ausschließen.
Ab diesem Punkt wird die Extended Reflection API aktiv. Sie liefert uns
nämlich nicht nur eine Liste der Methoden, sondern wir erhalten Liste von
ExtReflectionMethods, die wir direkt nach ihren Parametern und
Rückgabewerten fragen können. Dies ist einer der Hauptvorteile des 
WSDLGenerators, da er nicht selbst die Klassen parsen muss um die 
benötigten Informationen zu erhalten.

Jede gefundene so gefundenen Methoden bzw. jede hinzugefügte Funktion muss in die 
WSDL-Datei abgebildet werden.
Sollten bestimmte Funktionen nicht veröffentlicht werden, so kann das Policy-PlugIn,
siehe Abschnitt \ref{Policy-PlugIn},genutzt werden. Es erhält als Eingabe die
Liste der ExtReflectionMethoden und liefert eine gefilterte Liste zurück. Die 
Entscheidung, ob eine Methode veröffentlicht werden soll oder nicht, findet es in
der angeschlossenen Datenbank, die der Entwickler zuvor mit Hilfe des AdminTools
für die entsprechende Klasse füllen muss. Im AdminTool kann außerdem eine
Beschreibung der Methode in die Datenbank eingepflegt werden, die dann automatisch,
sofern das Policy-PlugIn genutzt wird, mit in der WSDL-Datei ausgegeben wird.

Das Hauptproblem der Abbildung von Methoden auf die WSDL-Beschreibung ist die 
Kodierung von komplexen Datentypen, da diese auch auf Clientseite erzeugt und 
verarbeitet werden müssen. Um das zu ermöglichen ist der 
WSDL-Generator in der Lage, rekursiv XML-Schemas zu erstellen, 
die alle gebräuchlichen Datentypen abdecken. Per Extended Reflection API 
werden so z.B. Klassen als solche erkannt. So ist der Generator in der Lage,
die Klasse rekursiv durch zu gehen und den Schema notfalls zu ergänzen, sollten 
in der Klasse selbst neue, komplexe Datentypen als Attribute enthalten sein.

Damit dabei kein redundanter Code erzeugt wird, vermerkt der Generator die 
erzeugten Schemanamen in einer Liste und greift während 
der Verarbeitung auch auf diese zu.

Der Generator erzeugt ein DOM-Dokument, das die 
WSDL-Struktur enthält. Das heißt im Einzelnen:
Es gibt das Definition-Element, in dem alle verwendeten Namespaces definiert werden und das alle anderen Beschreibungselemente enthält. Dann folgt 
die Type-Sektion, die XML Schema Beschreibungen für alle komplexen Datentypen enthält und, bei
Verwendung einer Literalkombination, außerdem die Anfrage- und Antwortnachrichten
definiert. Eine Liste der Methoden ist indirekt durch den Message-Teil gegeben, bei
dem für jede Methode ein Element für die Anfrage und ein Element für die entsprechende
Antwort vorhanden ist. Darauf folgt die PortType-Abteilung, in der die Methoden auf
Operationen abgebildet werden. Anschließend wird die Kombination aus Aufruf und 
Kodierung explizit angegeben in der Binding-Sektion und abschließend kommt noch das
Service-Element, bei dem dem der Service an einen Port gebunden wird.

Auf die erzeugte Struktur kann der Anwender dann per 
\texttt{getString()} oder per \texttt{getDOMDocument()} zugreifen, 
bzw. sie per \texttt{saveToFile(filename)} in das Dateisystem speichern. 
Für Entwickler gibt es noch die Möglichkeit durch 
\texttt{saveToFileAndStartSOAPServer(filename)} einen Soapserver 
zu starten um den Web Service sofort zu testen.

\section{WS-Security}
\label{sec:wss}
\subsection{Übersicht}
\label{sec:wss:Uebersicht}
Web Services sind heutzutage überall zu finden. Jeder will sie benutzen und anbieten. Dabei wird eine vermeintliche Interoperabilität angenommen, die keinesfalls garantiert ist. Denn auch zwischen den großen Middleware-Plattformen Java und .Net gibt es noch einige Probleme. Dennoch ist abzusehen, dass sich diese Probleme alsbald lösen lassen, bzw. schon heute gut umgangen werden können. Möchte man seine Web Services aber nicht jedem frei verfügbar anbieten oder wird auf einer Authentifikation bestanden, sei es aus gesetzlichen Gründen oder der Bereitstellung von kostenpflichtigen Inhalten, so werden die Grenzen der Spezifikationen von Web Services in ihrem normalen Umfang von WSDL, SOAP und UDDI schnell erreicht. Dies heißt nicht, dass keine möglichen Lösungen existieren, dennoch gehen die Lösungen schnell soweit auseinander, dass der Benutzer von Web Services den Überblick verliert. Die Frage nach der Sicherheit steht nun im Zeichen dieses Kapitels.

\subsection{Anforderungen an gesicherte Webservices}
\label{sec:wss:Anforderungen}
Wird von Sicherheit gesprochen, sind viele Dinge zu beachten. Bei Sicherheit handelt es sich meist nicht nur um funktionale, sondern auch um nicht-funktionale Anforderungen. Um Sicherheit in Software untersuchen zu können, existieren verschiedenen Kriterien. Im Allgemeinen sind dabei die Punkte Verfügbarkeit, Datenintegrität, Vertraulichkeit, Authentifikation und Autorisation anerkannt. Diese Aspekte werden hier im Weiteren nicht näher erläutert, sollen aber auf eine gewisse Sensibilität aufmerksam machen, die bei einer Umsetzung von Sicherheit gewährleistet werden muss.

Für eine Umsetzung von Sicherheitsaspekten bei der Verwendung von Web Services müssen vor Beginn der Arbeiten einige Designziele aufgestellt werden, die es einzuhalten gilt. Diese beeinflussen die Lösungsfindung entscheidend. Hierzu zählt vor allem, dass die Implementierung bzw. die Benutzung von Sicherheitsaspekten nicht zu Lasten des Anwendungentwicklers gehen darf. Die Implementierung eines Web Services muss vollständig unabhängig von möglichen Sicherheitstechniken sein. Dies liegt darin begründet, dass eine sichere Implementierung morgen schon als sehr unsicher gelten kann. Aus diesem Grund darf eine Sicherheits-Implementierung nur eine Erweiterung zur Business-Logik sein, welche schnell ausgetauscht werden kann. Ein weiterer Punkt betrifft eine möglichst große Interoperabilität. Auch wenn PHP nicht die klassische Software-Plattform für die Implementierung von Web Services ist, so muss eine Lösung dennoch aus Java und .Net genutzt werden können.

Das Thema Sicherheit umfasst einen riesigen Themenkomplex. Daher ist es nicht möglich, eine vollständige Sicherheitslösung in einem kurzen Zeitraum umzusetzen. Hierbei sind auch viele Reviews nötig, um wirkliche Sicherheit zu gewährleisten. Es musste daher auf einen Teil der zuvor genannten Sicherheitsaspekte das Hauptaugenmerk gelegt werden. Dies soll im Nachfolgenden bei der Umsetzung die Authentifizierung sein. Die Web Services werden dabei weiterhin unverschlüsselt übertragen. 
Allerdings dürfen andere Aspekte nicht außer Acht gelassen werden, so sollte z.B. die entstehende Lösung weiteren Sicherheitsstrategien nicht im Wege stehen.

\subsection{Mögliche Ansätze zur Absicherung von Web Service}
\label{sec:wss:Ansaetze}
Möchte man hier eine Lösung finden, fällt gleich ein grober Ablauf ein. Dieser besteht aus:
\begin{enumerate}
	\item Anmelden, sowie Verschlüsseln der Anmeldedaten auf Clientseite
	\item Die Anmeldedaten auf Serverseite abfragen und auswerten
	\item Nach der korrekten Authentifizierung wird die Anfrage an die Web Service Implementierung weitergeleitet
\end{enumerate}

Lösungen eines selbst implementierten Token-Prinzips sind immer möglich, stehen jedoch im Kontrast zu einer geforderten Interoperabilität. Demnach muss ein Standard gefunden werden, welcher genau diese Anforderungen erfüllen kann. In der Welt von Java und .Net hat dabei Web Service Security\footnote{Basiert auf Standard 1.0, am 17.2.2006 wurde die Version 1.1 veröffentlicht} von Oasis eine weite Verbreitung gefunden. Dieser Standard umfasst mehrere Teile. Das ist auf der einen Seite Soap Message Security zum Verschlüsseln von Nachrichten und der Behandlung von Fehlern. Auf der anderen Seite gibt es die Token Profiles\footnote{Hier wird nur das Username Token Profil 1.0 betrachtet}. Diese beschreiben einen Authentifizierungsmechanismus für Web Services. Sie erfüllen dabei idealerweise fast alle geforderten Ziele und wurden daher für eine Implementierung in PHP ausgewählt. Eine Umsetzung des Username Token Profile 1.0 steht nun im Mittelpunkt der weiteren Arbeiten. 

\subsection{Username Token Profile 1.0 im Detail}
\label{sec:wss:UTPDetail}
Das Username Token Profile 1.0 wurde von Oasis \cite{wss:oasis} erarbeitet. In der hier vorgestellten Version, handelt es sich, wie schon erwähnt nicht um die Version 1.1, da sie zu Beginn der Entwicklung nur als Entwurf vorlag und der erweiterte Funktionsumfang nicht benötigt wurde. Des Weiteren wird Version 1.0 schon durch diverse Middleware-Plattformen unterstützt und bietet somit eine gute Grundlage für Interoperabilitätstest und Anwendungen.
Der Standard beschreibt nicht neue Techniken, sondern gibt einen Rahmen vor, wie die benötigten Informationen in einem spezifizierten Format zu übertragen sind. Dabei wird kein Verschlüsselungsalgorithmus für das Passwort festgelegt, da dessen Wert kontinuirlich mit der Zeit abnimmt.

Das Format besteht aus dem ersten Tag \texttt{<wsse:Security>}, welches die Webservice Security Daten im SoapHeader kapselt. Darauf folgt ein Tag namens \texttt{<wsse:UsernameToken>}, der darauf aufmerksam macht, dass hier das Username Token Profil benutzt wird. Nun folgen die benötigten Daten, dabei gilt, \texttt{<wsse:Username>} muss immer angegeben werden und ist unverschlüsselt. Beim nächsten Tag \texttt{<wsse:Password Type=\grqq...\grqq>} unterscheidet man zwei Typen:
\begin{itemize}
\item \emph{PasswortText (default)}

Hierbei kann das type Feld leer gelassen werden und als Daten sind nur der Username und das Passwort (bzw. Passwortäquivalent) notwendig.
\item \emph{PasswordDigest}

Um sicherzustellen, dass keine Anfrage zweimal gesendet werden kann (Replayattacke), wird das Passwort mittels eines Zeitstempels und einer Zufallszahl (Nonce) verschlüsselt. Als \texttt{Type}-Wert muss hier grundsätzlich PasswordDigest gesetzt sein. Die Formel nach welcher sich die Verschlüsselung zusammensetzt, sieht nun wie folgt aus:
\\
\\
\texttt{PasswordDigest = Base64( SHA-1( Nonce + Created + Password ))}
\\
\\
Die Zufallszahl wird mit dem Datum und dem Passwort (bzw. Äquivalent) zusammengekettet, danach wird mittels eines SHA-1-Algorithmus dieser Wert gehasht und nochmals mit Base64 kodiert. Auf Serverseite wird mittels der bekannten Daten (Zufallszahl und Zeitstempel sind im Header enthalten) ebenfalls ein Vergleichswert erschaffen, um damit dann die Korrektheit der Anfrage zu überprüfen. Somit ist jede Anfrage nur genau einmal gültig (Hashwert ist jedes Mal verschieden). Identische Anfragen werden natürlich von der Serverseite negiert.
\end{itemize}
Die letzten zwei Tags sind optional und senden zum einen die Zufallszahl(\texttt{<wsse:Nonce>}) im Base64 Format und zum anderen den Erzeugungszeitpunkt(\texttt{<wsu:Created>}) mit.
\\
\\
\texttt{Nonce = Base64( Nonce )}
\\
\\
Bei den Tags werden nun zwei Namespaces sichtbar, dabei handelt es sich einmal um wsse\footnote{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-
1.0.xsd} und zum Anderem um wsu\footnote{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-
1.0.xsd}.

Des Weiteren sollen Anfragen mit einem alten Zeitstempel zurückgewiesen und ein Cache mit schon benutzen Zufallszahlen geführt werden. Als Minimum gibt der Standard eine Empfehlung von fünf Minuten an.

Passwortäquivalent bedeutet in diesem Zusammenhang, dass dieses extern verschlüsselt sein kann und sollte. Bei dieser Umsetzung gilt grundsätzlich das Passwörter immer MD5 gehasht sein müssen. Dementsprechend gilt auch beim PasswortText, dass ein Passwort einem \texttt{MD5(Passwort)} entspricht und nicht nur durch ein reines Passwort repräsentiert wird.

\begin{figure}[!htb]
\centering
\includegraphics[width=3.4in]{pics/UTPCode}
\caption{Soap Header Beispiel Username Token Profil}
\label{wss:UTPCode}
\end{figure}

Für nähere Details sei hier auf den Standard \cite{wss:usernameTokenProfile} verwiesen. Es wurde an dieser Stelle versucht kurz und knapp die grundlegenden Ideen des Standards zu vermitteln. Im Nachfolgenden soll die Umsetzung in PHP näher beleuchtet werden.

\subsection{Umsetzung des Servers in PHP}
\label{wss:UmsetzungServer}

\subsubsection{Vorhandene Umsetzungen}
\label{wss:VorhandeneUmsetzungen}
PHP bietet seit der Version 5 eine SOAP Extension, welche es erlaubt Web Services aufzusetzen, beziehungsweise angebotene Dienste zu verwenden. Eine Möglichkeit der Verwendung von Sicherheitsaspekten bleibt einem dabei allerdings verwehrt. Die Implementierung des Username Token Profiles für PHP wird auf Basis der vorhandenen Klassen SoapClient und SoapServer erfolgen. Dies hat den klaren Vorteil, dass der gesamte Teil zum Abarbeiten von Web Services schon als gelöst angesehen werden kann. Im Idealfall profitiert die zu erstellende Lösung einfach aus Verbesserungen der SOAP Extension. Die Extension selbst ist in C geschriebenen und bietet somit einen klaren Geschwindigkeitsvorteil gegenüber PHP Klassenbibliotheken. Die erstellten PHP Klassen erben von diesen bzw. erweitern sie um die zusätzlichen benötigten Aspekte.

\subsubsection{Probleme}
\label{wss:Probleme}
Diese Idealvorstellung erweist sich allerdings schnell als nicht trivial. Dies liegt einerseits in der schlechten PHP Dokumentation, welche ein Review des SourceCodes unerlässlich macht und andererseits in den noch vorhanden \glqq Features\grqq. Unter anderem ruft der SoapServer anhand des Tagnamens im SoapHeader automatisch Methoden auf, welche den gleichen Namen besitzen. Dies kann Potential für eine Sicherheitslücke darstellen. 
Es muss daher eine Lösung gefunden werden, welche es ermöglicht alle Headerinformationen aus der SoapMessage nach deren Verwendung zu löschen. 
Die vorhandene Implementierung des SoapServers hat noch einen weiteren Nachteil. Sie wirft nicht unter allen Umständen korrekte SoapFaults. Das Werfen eigener Fehler sollte hingegen immer korrekt ablaufen, gerade wenn Exceptions zur Laufzeit auftreten.

\subsubsection{Extended Soap Server}
\label{wss:ExtendedSoapServer}
\begin{figure}[!htb]
\centering
\includegraphics[width=3.4in]{pics/klassenstrukturServer}
\caption{Klassenstruktur der Webservice Security}
\label{wss:klassenstrukturServer}
\end{figure}
Um die Sicherheit kapseln zu können, wurde der \glqq Extended Soap Server\grqq~entwickelt.

Es sei an ein wichtiges Designziel erinnert: Weitere Standards sollten möglichst einfach integrierbar sein. Aus diesem Grund muss dass Problem der Behandlung von Sicherheitsaspekten abstrahiert werden. Dies ist hier geschehen und wird im Weiteren näher erläutert.

\begin{itemize}
\item \emph{XmlParser}

Bei Web Services handelt es sich um eine Übertragung von XML konformen Dokumenten. Da ist es nur offensichtlich, dass die Implementierung von XML Handlern den Weg zum Designziel massiv erleichtern können. Es gibt zwei grundsätzlich verschiedene Arten ein Dokument zu parsen. Einerseits die DOM-Parser, welche im Speicher die gesamte Baumstruktur aufbauen und andererseits die SAX-Parser (Event-Driven). Sie sind einfach beschrieben Tagsucher, welche bei jedem vorkommenden Tag eine Methode aufrufen. Für eine Umsetzung in PHP empfehlen sich dabei klar die SAX-Parser, da sie speichereffizienter agieren. 
Diese lassen sich in PHP nicht direkt realisieren, doch stehen Grundelemente bereit. Eine abstrakte Implementierung eines solchen Parsers, welcher leere Methoden implementiert, aber schon eine Methode \texttt{parse()} bereitstellt, ist der  \texttt{XmlParser}. Diese Methode hat als Rückgabewert einen Fehlercode, welcher angibt ob die Abarbeitung und Auswertung des Parsens erfolgreich war (\texttt{return 0}).

\item \emph{XmlParserExtended}

Der \texttt{XmlParser} wird durch \texttt{XmlParserExtended} erweitert, wodurch es möglich ist, Headerabschnitte zu löschen. Da jeder Parser das gesamte Dokument durchsucht, ist es nötig schon benutzte Teile zu entfernen, um doppelte Datenauswertungen zu verhindern. Somit ist es ebenso möglich, durch die richtige Implementation der Methode \texttt{deleteHeader()} das Sicherheitsproblem der Ausführung von Methoden durch Header-Tags zu verhindern (siehe \ref{wss:XmlSoapHeaderParser} \emph{XmlSoapHeaderParser}).

Die XML Soap Parser sind demnach eine Anwendung des Strategy-Pattern\footnote{\glqq Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.\grqq \cite{wss:designPatterns}}, welches es erlaubt mehrere Algorithmen unter einem einheitlichen Interface anzusprechen und auszutauschen. Mit dieser Möglichkeit kann ein Chainhandler aufgebaut werden. Dabei handelt es sich um die Möglichkeit, beliebig viele XML Soap Parser dem \texttt{ExtendedSoapServer} zu übergeben und diese nach der Reihenfolge abzuarbeiten.

Das Username Token Profile ist folglich nur als eine konkrete Umsetzung des \texttt{XmlParserExtended} (siehe \ref{wss:XmlSoapSecParser} \emph{XmlSoapSecParser}) anzusehen. Dabei wird in der \texttt{parse()}-Methode  auf das Interface \texttt{ICheckUserRunnable} verwiesen und überlässt ihm mittels der geparsten Werte für Username, Passwort, Nonce und Created die Auswertung der Anfrage. Nachdem diese erfolgt ist, werden alle entsprechenden Tags mittels der \texttt{delete()}-Methode gelöscht.
\end{itemize}

Durch die Trennung von Parser und SoapServer ist die Lösung unabhängig vom Parser und somit dem zu implementierenden Standard. Eine Umstellung auf andere Möglichkeiten ist somit leicht möglich. 

Damit eine Behandlung der SoapMessage noch vor der Weiterleitung an den PHP eigenen SoapServer erfolgen kann, muss der Inhalt aus \texttt{\$HTTP\underline~RAW\underline~POST\underline~DATA} ausgelesen und durch die Parser jeweils, wenn nötig, angepasst werden. 
Das Ergebnis muss wiederum in dieser Variable gespeichert werden, da die gekapselte SoapServer-Implementierung auf diese Variable zugreift.

Es soll hierbei erwähnt werden, dass die Reihenfolge der Parser einen entscheidenden Faktor spielen kann. Ein Parser, welcher den gesamten SoapHeader löscht, darf erst zum Schluß ausgeführt werden. Da allerdings der \texttt{ExtendedSoapServer} keine Kenntnis über den semantischen Inhalt der genutzten XML Parser hat, ist der Entwickler des \texttt{ExtendedSoapServer} dazu aufgefordert, die XML Parser in der richtigen Reihenfolge dem \texttt{ExtendedSoapServer} mitzuteilen. Diese Reihenfolge wird bei der Ausführung beachtet.

Nachdem die großen Probleme gelöst werden konnten, bleibt nur noch die Frage nach den SoapFaults(siehe \ref{wss:SoapFaults} \emph{SoapFaults}). Als gute Lösung erwies sich in Tests die Verwendung eines extra SoapServers nur für Fehlermeldungen. Dabei muss ein minimaler Web Service bereitgestellt werden, welcher nicht einmal Dienste anbieten muss. Dieser dient nur zum Aufsetzen des Servers. Damit ist es möglich korrekte SoapFaults zu erstellen. Die Verhinderung der genannten Sicherheitsprobleme ist damit erfolgt.

Allerdings ist es nun leider nicht mehr möglich einen \texttt{ExtendedSoapServer} als Ableitung von SoapServer zu implementieren, da nun zwei Exemplare eines SoapServers benötigt werden. Demnach kapselt der \texttt{ExtendedSoapServer} nun sämtliche Funktionen des SoapServers und 
erweitert ihn um unsere Bestandteile (siehe Abb. \ref{wss:klassenstrukturServer}).

Sollten später die Probleme in PHP behoben werden, ist eine Umstellung auf Vererbung aber nicht grundsätzlich unmöglich. Da eine Trennung der XML Behandlung erfolgte, ist dies sogar mit relativ wenig Aufwand möglich.

Die Verwendung des \texttt{ExtendedSoapServers} ist nun nahezu identisch zu der des normalen SoapServers. Es wurde lediglich eine Funktion nach außen hinzugefügt: \texttt{addXmlHandler()} fügt entsprechend der Erläuterung des ChainHandlers neue XML Soap Parser hinzu und führt sie aus.

\subsubsection{XmlSoapSecParser}
\label{wss:XmlSoapSecParser}
Nachdem die Umsetzung eines Servers näher erläutert wurde, besteht nun die spannende Frage, wie der XML Soap Parser für das Username Token Profile aussieht.

Der Parser sammelt aus dem Header alle notwendigen Daten zusammen. Dazu zählen Username, Password, Nonce und das Created-Tag. Sind die benötigten Daten ermittelt, so werden die Daten an eine Implementierung des Interfaces \texttt{ICheckUserRunnable} übergeben. Dieses wird intern in der Methode \texttt{parse()} aufgerufen, welche damit auch die Fehler nach außen reichen kann.

Die schon oft erwähnte Methode \texttt{deleteHeader()} dient nun dazu alle oder nur Teile eines Headers zu entfernen. Grundsätzlich ist es hiermit auch möglich den Inhalt der gesamten SoapMessage zu löschen, was aber wenig Sinn macht. Bei der Implementierung muss die Variable \texttt{\$this->deleteTag} einfach mit dem betreffenden Tag gesetzt werden. Nach der \texttt{parse()} Methode wird dann automatisch eine Methode des XML Parsers durch den \texttt{ExtendedSoapServer} aufgerufen, welche den gesamten Inhalt des Tags löscht. Soll kein Inhalt des SoapHeaders entfernt werden, so braucht die Variable \texttt{\$this->deleteTag} einfach nicht gesetzt zu werden. In der konkreten Implementierung des \texttt{XmlSoapSecParsers} wird der gesamte Inhalt des Security Tags gelöscht.

\subsubsection{ICheckUserRunnable und CheckUserRunnable}
\label{wss:CheckUserRunnable}
Die Trennung ist notwendig, da bei einer Anwendung in einem Unternehmen immer wieder verschiedene Datenhaltungstechniken verwendet werden. Nur so ist gewährleistet, eine flexible Implementierung zu erstellen. In der Implementierung des Interfaces \texttt{ICheckUserRunnable} ist die eigentliche Logik des Standards enthalten. Hier wurde als Beispiel eine Implementierung für die tele-TASK-Benutzerverwaltung erstellt.

Um den Ablauf zu verdeutlichen wurde ein Petrinetz erstellt, welches die Reihenfolge der Überprüfungen verdeutlicht. Es besteht aus zwei Teilen um die Komplexität etwas zu verringern. (siehe Abb. \ref{wss:WebserviceSecurityAblaufPart1} und \ref{wss:WebserviceSecurityAblaufPart2})

\begin{figure}[!htb]
\centering
\includegraphics[width=3.4in]{pics/WebserviceSecurityAblaufPart1}
\caption{Username Token Profile - Ablauf Teil 1}
\label{wss:WebserviceSecurityAblaufPart1}
\end{figure}

Vorweg sei gesagt, die Umsetzung des Username Token Profile benötigt eine eigene Tabelle. Diese wird durch ADOdb und der Klasse \texttt{CheckUserDB} gekapselt. Die Tabelle besitzt zwei Spalten mit den Attributen für Nonce (Primary Key) und dem Created Zeitstempel. Mittels derer lassen sich doppelte und zu alte Anfragen filtern.

Ein weiterer wichtiger Punkt ist, dass das type Feld im Password Tag nicht erkannt wird. Um dieses Problem, welche Version der Anfrage (PasswordText oder PasswordDigest), zu lösen, wird auf die gesetzten Tags geachtet. Das heißt zum Beispiel, dass beim PasswordText die optionalen Tags nicht gesetzt sein dürfen.

\emph{Ablauf}

Als erstes wird, wie schon oft beschrieben, der SoapHeader ausgelesen und die notwendigen Daten übermittelt. Es lassen sich mehrere Wege durch das Petrinetz finden, von links nach rechts gilt:

\begin{enumerate}
	\item Sollte die Zufallszahl exklusiv oder der Zeitstempel fehlen wird ein Fehler zurückgegeben. Daher liefert die \texttt{parse()} Funktion des \texttt{XmlSoapSecParser} nicht 0 sondern -101 (siehe \ref{wss:SoapFaults} \emph{SoapFaults})
	\item Hierbei handelt es sich um PasswordText, dafür müssen sowohl Nonce als auch Created fehlen. Anschließend findet die Authentifikation statt. Hierbei kann es passieren, dass ein Benutzer unbekannt ist (-104), sein Passwort ungültig ist (-105) oder im Erfolgsfall das globale Userobjekt erzeugt und die Anfrage an den Webservice weitergeleitet wird, sofern keine anderen Parser Fehler auslösen.
	\item Der gesamte Security Header fehlt und es kann somit an dieser Stelle ein Gastaccount geladen werden.
	\item Als letzter Zweig wird nun PasswordDigest abgearbeitet. Dafür wird als erstes das Alter der Anfrage überprüft. Dabei gilt, alle Anfragen älter als fünf Minuten zu verwerfen (-106). Sollte dies nicht der Fall sein wird die Zufallszahl dekodiert (Base64), alle alten Zufallszahlen werden entfernt und es wird überprüft ob diese Zahl schon vorhanden ist (-106).

\begin{figure}[!htb]
\centering
\includegraphics[width=3.4in]{pics/WebserviceSecurityAblaufPart2}
\caption{Username Token Profile - Ablauf Teil 2}
\label{wss:WebserviceSecurityAblaufPart2}
\end{figure}
	
Sollte nun die gestellte Anfrage nicht doppelt oder zu alt sein, so wird zuerst das Passwort (MD5 verschlüsselt) vom Server geholt. Sollte dies fehlschlagen ist hier ebenfalls der Benutzer unbekannt(-104). Mit dem nun erhaltenen Passwort wird auf Serverseite ein zweiter Vergleichshashwert erzeugt und mit dem Zugesandten verglichen. Konnte der Hashwert korrekt erzeugt werden, so ist die Anfrage gültig und kann weitergereicht werden (Globales Userobjekt wird erzeugt und \texttt{return 0} als Rückgabewert geliefert). Andernfalls wird auch hier ein Fehler zurückgegeben (-105) 
\end{enumerate}


\subsubsection{XmlSoapHeaderParser}
\label{wss:XmlSoapHeaderParser}
Dieser Parser löscht den gesamten SoapHeader. Demnach nutzt er die Funktionalität des \texttt{XmlParserExtended} zum Löschen von Tag-Abschitten. Dies funktioniert wie schon zuvor in \texttt{XmlSoapSecParser} beschrieben. Dabei ist der einzige Unterschied, dass nicht nur das Security-Tag entfernt wird, sondern gleich der gesamte SoapHeader. Dieser Parser sollte demnach als allerletztes an den \texttt{ExtendedSoapServer} übergeben werden.

\subsubsection{SoapFaults}
\label{wss:SoapFaults}
Das Thema SoapFaults basiert ebenfalls auf dem Web Service Security Standard (siehe \cite{wss:oasis} Soap Message Security 1.0) und ist somit wohl definiert. Die folgende Tabelle \ref{wss:SoapFaultsTable} zeigt den internen Fehlercode und den zugehörigen standardisierten Fehlercode sowie dessen Stringbeschreibung.

\begin{table}[!h]
\caption{Fehlercodes}
\label{wss:SoapFaultsTable}
\begin{tabular}{|l|l|l|}
\hline
Interner & Fault- &  Fault-  \\
Code & Code & String \\
\hline
-101 & wsse:UnsupportedSecurityToken & An unsupported token \\ & & was provided\\
\hline
-102 & wsse:UnsupportedAlgorithm & An unsupported signature \\ & & or encryption algorithm \\ & & was used\\
\hline
-103 & wsse:InvalidSecurity & An error was discovered \\ & & processing the \\ & & <wsse:Security> header\\
\hline
-104 & wsse:InvalidSecurityToken & An invalid security \\ & & token was provided\\
\hline
-105 & wsse:FailedAuthentication & The security token could \\ & & not be authenticated \\ & & or authorized\\
\hline
-106 & wsse:FailedCheck & The signature or \\ & & decryption was invalid\\
\hline
-107 & wsse:SecurityTokenUnavailable & Referenced security token \\ & & could not be retrieved\\
\hline
\end{tabular}
\end{table}

\subsubsection{Fazit}
\label{wss:Fazit}
Als Abschluss soll noch einmal ein kritischer Blick auf die erstellte Lösung geworfen werden. Dabei sind viele der geforderten Ziele umgesetzt worden. Die Benutzung des \texttt{ExtendedSoapServer} unterscheidet sich nur durch die Anwendung von XML Parsern. Die WSDL-Beschreibung und die Web Service-Klasse bleiben dagegen völlig identisch.

Die unabhängige Implementierung der Sicherheitsaspekte konnte durch das Stategy-Pattern gelöst werden. Eine Umsetzung von weiteren Standards steht demzufolge nichts entgegen.

Etwas unschön ist dabei, dass der \texttt{ExtendedSoapServer} nicht direkt von dem PHP eigenen SoapServer abgeleitet werden konnte. Es ist daher eher eine Frage der Zeit, bis diese Lösung etwas umstrukturiert werden muss. Dies wird aber wie schon zuvor erwähnt mit wenigen Handgriffen zu machen sein.

Es kann auf Grund dessen im Gesamten eine positive Bilanz gezogen werden, vor allem dadurch, dass die Interoperabilität gewährleistet ist. (siehe \ref{wss:Interoperabilitaet} Interoperabilität)

Der Server ist vollständig erstellt. Es fehlt dabei allerdings die Möglichkeit die abgesicherten Web Services unter PHP zu verwenden. Dies soll an dieser Stelle nachgeholt werden.

\subsection{Umsetzung des Clients in PHP}
\label{wss:UmsetzungClient}

\begin{figure}[!htb]
\centering
\includegraphics[width=3.4in]{pics/UMLSecureSoapClient}
\caption{Klassenstruktur des Clients}
\label{wss:UMLSecureSoapClient}
\end{figure}

Der Client ist punktuell für das Username Token Profile erweitert worden. Dabei konnte hier von einer Vererbung profitiert werden. Aus der von PHP gelieferten Klasse \texttt{SoapClient} wird der \texttt{SecureSoapClient}. Dazu wurde der Konstruktor leicht verändert, damit die zusätzlichen Parameter wie Name und Passwort entgegengenommen werden können. Dieser bietet demnach nun 4 Parameter an \texttt{\underline~\underline~construct(\$wsdl , \$options, \$user, \$pw)} in denen die zusätzlichen Informationen übergeben werden.

Mit den zusätzlichen Daten generiert der Client bei jedem \texttt{\underline~\underline~call()} Aufruf automatisch den benötigten SoapHeader. Die Benutzung der Klasse ist dabei idealerweise nahezu identisch zum SoapClient und unterscheidet sich lediglich im erweiterten Konstruktor.

Die Erstellung des SoapHeaders ist unter PHP allerdings eine Sache für sich. Es ist erforderlich eine Struktur von Structs zu generieren, um einen konformen Header erzeugen zu können. Hierbei kommen auch die PHP eigenen Klassen \texttt{SoapVar} und \texttt{SoapHeader} zum Einsatz. Der sogenannte \texttt{SecurityStruct}, welcher das Username Token kapselt, wird \texttt{SoapVar} übergeben, welcher daraus eine XML konforme Darstellung erzeugt. Das Ergebnis wird anschließend dem \texttt{SoapHeader} übergeben. Dabei ist leider zu beachten das type-Attribute innerhalb eines Tags nicht erzeugt werden können. Damit ist die Interoperabilität vom PHP Client zu beliebigen Web Service Security Servern leider nicht möglich. Auf Grund dessen, dass der Client nur PasswortDigest unterstützt, aber dies im Tag nicht identifizieren kann, wird er von anderen Servern als PasswortText interpretiert und dies sorgt für eine Ablehnung der Anfrage (PasswordText versus PasswortDigest). Bei dem erstellten \texttt{ExtendesSoapServer} ist dies kein Problem, da er dies an Hand der übergebenen Argumente herleitet und somit der Server einfach und problemlos mit dem Client kommunizieren kann. Demnach ist ein Erfolg bei anderen Servern abhängig von deren Implementierung.

Im Großen und Ganzen ist die Implementierung des Clients recht unspektakulär, jedoch werden einige nicht dokumentierte Funktionen in PHP benutzt, was die Entwicklung weitaus schwieriger gestaltet hat, als man anfänglich denken würde.

Dieser Client kann somit durchaus als Vorlage für eigene Security Vorstellungen dienen. Eine Umstellung auf PasswordText wäre relativ problemlos möglich, um Interoperabilität zu anderen Servern gewährleisten zu können.
 
\subsection{Einbettung in das Gesamtsystem}
\label{wss:Einbettung}

Da nun die Implementierung des Servers und des Clients abgeschlossen wurde, soll nun ein Blick auf das Gesamtsystem geworfen werden. 
Dabei wird das altbekannte Bild \cite{WebServicePart2} Abb. \ref{wss:AufbauWithDetailSecurity} zu Grunde gelegt.
 In diesem wurde nun der Security Agent detaillierter dargestellt. Extended Server übernimmt dabei die Kapselung des eigentlichen PHP Soap Server und leitet die Anfrage an die zwei Parser weiter, die damit entsprechend ihrer Funktion umgehen. Als letzten neuen Bestandteil übernimmt User Token Check die Authetifikation mittels der Datenbank und dem User Management.

Die WSDL Adminoberfläche wurde so erweitert, dass sie mit einem zusätzlichen Flag sichere Web Services erstellen kann.

\begin{figure}[!htb]
\centering
\includegraphics[width=3.4in]{pics/AufbauWithDetailSecurity}
\caption{Gesamtaufbau mit Sicherheit}
\label{wss:AufbauWithDetailSecurity}
\end{figure}

\subsection{Interoperabilität}
\label{wss:Interoperabilitaet}

Um die Interoperabilität nachzuweisen, wurde der sichere Web Service einmal mit einem C\# und zum anderen mit einem Java Client getestet. 
Beide Interoperabilitätstest verliefen erfolgreich und sind dem Anhang des Projektes zu entnehmen. 
Die Umsetzung des User Token Profil auf Client Seite wird hier nicht näher erläutert. Es sei hier auf die Referenzimplementierungen\footnote{Microsoft Web Services Enhancements 3.0 www.microsoft.com und Java Axis 1.3 http://ws.apache.org/axis/} verwiesen.

%Stefan: wo bzw. an welcher stelle sinnvoller weise informationen zu REST eingebunden werden sollte, müsste nochmal durchdacht werden. hier erstmal der erste rohtext. Anmerkung und Kommentare sind willkommen
\section{RESTful Web Services}
\subsection{Representational State Transfer}
Der Begriff REST bzw. Representational State Transfer geht auf 
R. T. Fielding zurück und wird in \cite{RESTServices} im Zusammenhang 
mit Web Services näher beleuchtet. Für Web Services im Allgemeinen 
ist eine Implementierung des REST-Archtiekturstils in Verbindung mit 
dem \emph{Hypertext Transfer Protocol} (HTTP) besonders interessant 
und soll hier kurz aufgegriffen werden.

Der Hauptgedanke bei RESTful Web Services liegt in der Verwendung 
eines uniformen und minimalen Interfaces für alle Web Services, 
unabhängig von einem speziellen Einsatzbereich. Dies steht damit 
im Gegensatz  zu auf SOAP aufbauenden Web Services, welche als 
gemeinsame Basis nur das SOAP-Nachrichtenformat verwenden, selbst 
jedoch jeweils komplett unabhängig davon eigene Nachrichtenprotokolle 
und Schnittstellen definieren.

Wie in \cite{RESTServices} dargelegt, hat es verschiedene Vorteile, 
eine allgemein gültige Schnittstelle zu verwenden, unter anderem 
wird damit die Interoperabilität verbessert, da unabhängig von 
einer speziellen Implementierung Aussagen über das zu erwartende 
Verhalten getroffen werden können. In Bezug auf HTTP-REST ergeben 
sich außerdem Vorteile bei der Verwendung von URI (Uniform Resource 
Identifier) bezogenen Fähigkeiten von diversen bestehenden Standards 
(z.B. XML-Dialekte), da so die Ressourcen eines RESTful Web Services 
ohne Umwege direkt in diesen Anwendungen verwendet werden können. 
Bei SOAP basierten Diensten ist für solch eine Verwendung bisher 
immer ein Zwischenschritt nötig, da die Ressourcen dieser Dienste 
in einem eigenen Namensraum definiert sind.

\subsection{Realisierung mit Hilfe des Toolkits}
Für die Erstellung eines Web Services nach dem REST-Architekturstil 
sind verschiedene konzeptionelle Schritte nötig, die im Tutorial 
\cite{RESTTutorial} und in \cite{RESTServices} erläutert werden.

Prinzipiell sollte man sich an dieser Stelle des Konzepts einer 
\texttt{Remote-Facade} \cite{EnterprisePatterns} bedienen, welche 
das System nach außen hin in geeigneter Weise kapselt und die 
Methoden zum Abfragen und Manipulieren der Ressourcen des Dienstes 
bereitstellt.

Der Toolkit stellt nun die benötigten Mechanismen bereit, um den 
entworfenen URI-Namensraum des REST Services auf diese Methoden 
abzubilden und die Ressourcenrepräsentationen in geeigneter Weise 
wählen zu können. Dafür lässt sich über einen regulären Ausdruck 
der Aufbau der URIs angeben, welche den Ressourcen entsprechen, 
die durch eine Methode repräsentiert werden. Für jede dieser 
Methoden kann außerdem der passende Serializer sowie Deserializer 
angegeben werden, um die Anfragedaten in programmiersprachliche 
Konstrukte bzw. in ein gewähltes Datenformat zu überführen.

Als Ergebnis wird mit Hilfe eines Tools aus diesen Angaben heraus 
eine Art \emph{Deployment Descriptor} generiert, welcher vom durch das 
Toolkit bereitgestellten \texttt{RESTServer} interpretiert wird, um die 
Anfragen an den Service abzuarbeiten.

\subsection{Sicherheit für RESTful Web Services}
Da diese Form der Web Services allein auf HTTP aufsetzt, kann hier 
ohne weitere Schwierigkeiten auf die Standardmechanismen zur 
Gewährleistung von Sicherheit zurückgegriffen werden. Sei dies 
nun mit \emph{HTTP over TLS} (HTTPS) \cite{rfc:2818} die 
Verschlüsselung der Datenübertragung oder die Basic bzw. Digest 
Authentifizierungsmechanismen \cite{rfc:2617} zum Steuern des 
Zugriffs auf den Service. HTTPS ist in den meisten Fällen 
anwendungsunabhängig über den HTTP-Server realisierbar, für die 
Authentifizierung hingegen ist oft eine direkte Einbindung in die 
Anwendung wünschenswert.

Diese Anbindung erfolgt über die Implementierung des 
\texttt{AuthProvider}-Interfaces. Die kann dann über eine 
entsprechende Konfiguration des \texttt{RESTServers} verwendet werden. 
Je nach gewünschtem Authentifizierungsverfahren gilt es hier 
darauf zu achten, dass gegebenenfalls die Nutzerpasswörter in 
einer geeigneten Art und Weise abgelegt werden. Details dazu sind 
in der Beschreibung des Interfaces bzw. im entsprechenden Abschnitt 
des Tutorials zu finden.

\section{Administrations-Tool \& Policy-PlugIn}
Das Administrations-Tool ist eine klassische Web-Applikation, die der 
einfachen Konfiguration des Web Service Frameworks dient. 
%Stefan: +während der Erstellung, oder noch allgemeiner, aber auch für eine Einleitung ein wenig zu knapp, oder?
Das Policy-PlugIn hingegen fungiert als Filter für Web Service Klassen bzw. deren Methoden.

\subsection{Administration Tool}
Das Administrations-Tool soll dem Benutzer die Handhabung 
des Web Service Frameworks erleichtern. Das Web Service 
Framework stellt eine Handvoll n\"{u}tzlicher Programme 
zur Verf\"{u}gung, die jedoch einzeln bedient werden m\"{u}ssen. 
Hier setzt das Administrations-Tool an, dass eine intuitive und 
zentrale M\"{o}glichkeit der Administration und Konfiguration 
bieten soll. 

Das Administrations-Tool nutzt eine eigene Bibliothek, 
die die grundlegende Funktionalit\"{a}t zur Verf\"{u}gung stellt,
in dem sie die Anbindung an die externen Tools kapselt. 
Darüber hinaus wird für die Anbindung der Datenbank ADOdb genutzt
und das Benutzerinterface wird mit Hilfe der Smarty Template Engine 
realisiert. 
%Stefan: was willst du damit alles ausdrücken? könntest du das hier mit ausformulieren, das es in einer "`eigenen PHP-Datei"' ist, dürfte nicht von all zu großem interesse sein
%gelöscht stefan: Der Anwendungskern befindet sich letztendlich in einer eigenen PHP-Datei. 

Allgemein hat der Nutzer die M\"{o}glichkeit Klassen beim 
Administrations-Tool zu registrieren und diese anschlie\ss{}end 
zu konfigurieren. Klassen werden entweder automatisch in einem 
gegebenen Verzeichnis gesucht oder k\"{o}nnen einzeln angegeben 
werden. Dabei kann schon der Programmierer einer Web Service 
Klasse mit Hilfe des Tags \texttt{@webservice} seine Klasse 
als Web Service Klasse markieren. So markierte Klassen k\"{o}nnen 
vom Administrations-Tool herausgefiltert bzw. explizit gesucht werden. 
Zu einer registrierten Klasse kann nun angegeben werden, welche ihrer 
Methoden letztendlich ver\"{o}ffentlicht werden sollen. Des Weiteren 
hat der Administrator die Möglichkeit sich Kommentare zu den Klassen 
und Methoden aus dem Quellcode anzeigen zu lassen. Zu diesen kann er 
zus\"{a}tzlich eigene Kommentare hinzuf\"{u}gen, die dann von anderen 
Programmen weiterverwendet werden k\"{o}nnen. Eines dieser Programme 
ist der WSDL-Generator, der vom Administrations-Tool genutzt wird 
um WSDL-Dateien zu erzeugen. Diesem k\"{o}nnen die eigenen Kommentare 
zur Beschreibung von Web Service Klassen und Methoden \"{u}bergeben 
werden. Ein weiteres Programm, das vom Administrations-Tool genutzt 
wird, ist der Adapter-Generator, der zur Erzeugung von speziellen Adapter-Klassen dient. 

Letzendlich erzeugt das Administrations-Tool mit Hilfe der Generatoren und 
der Informationen zu den Web Service Klassen die jeweils 
notwendigen Dateien zur Bereitstellung eins Web Services und legt
diese an dem vom Benutzer gewünschten Pfad im Dateisystem ab.

%del Stefan: Das Resultat dieses Generators kann dazu verwendet werden, 
%Stefan: der bezog zum rest-server ist hier etwas unglücklich
%Stefan: muss wohl noch nen abschnitt zu rest einfügen (weiter vorne), mal sehen wie es dann aussieht
%del Stefan: einen SOAP bzw. REST-Server aus einem Template heraus zur Verf\"{u}gung zu stellen. 
Das Administrations-Tool bietet auch einen Wizard, mit Hilfe 
dessen Web Services im Frage-Antwort-Stil aufgesetzt werden k\"{o}nnen.

\begin{figure}[!htb]
	\centering
		\includegraphics[width=3.4in]{pics/arch_admin-tool}
	\caption{Aufbaudiagramm des Administrations-Tools}
	\label{fig:arch.admin-tool}
\end{figure}

\subsection{Policy-PlugIn}
\label{Policy-PlugIn}
Wie schon erw\"{a}hnt, dient das Policy-PlugIn der Filterung von 
Web Service Methoden. Hauptnutzer des PlugIns ist der WSDL-Generator. 
Dieser bekommt mit Hilfe des PlugIns diejenigen Methoden einer Klasse 
heraus, die zur Ver\"{o}ffentlichung mittels Web Service gedacht sind. 
Auch das Policy-PlugIn ben\"{o}tigt eine Datenbankanbindung, 
welche wiederum durch ADOdb gekapselt wird. Durch das PlugIn werden 
in der Datenbank Informationen zu Klassen, deren Methoden und 
Kommentaren hinterlegt. Schon durch die Benutzung des PlugIns 
wird eine Klasse samt ihrer Methoden registriert und kann dann 
wie beschrieben konfiguriert werden.

\section{Anwendungsbeispiel}
\label{sec:Anwendungsbeispiel}
Parallel zur Erstellung des Web Service Toolkits wurde 
eine Beispielanwendung, die auf der alten tele-TASK-Datenbank 
aufbaut, entwickelt. 
Die Beispielimplementierung zeigt den Einsatz von Web Services 
und erm\"{o}glicht das Manipulieren der tele-TASK-Datenbank. 
Diesbez\"{u}glich stehen allerdings nur vorgegebene 
Anfragemöglichkeiten zur Verf\"{u}gung. Die einzigen zu 
\"{u}bergebenen Elemente sind Objekte des entsprechenden Typs, 
wie z.B. Lectures oder News.
Aus diesen Klassen k\"{o}nnen WSDL-Dateien erzeugt und dann auf 
Funktionalit\"{a}t getestet werden. Daf\"{u}r ist eine Kommentierung 
strikt nach dem Style Guide erforderlich. Ansonsten kann der 
WSDL-Generator die Elemente nicht korrekt identifizieren und es kann 
keine WSDL-Datei erzeugt werden.
Für eine korrekte Implementierung der auf ADOdb basierenden Datenbankabstraktionsschicht, 
welche mittels einem Web Service angesprochen wird, müssen minimal das 
Mapping und die Initialisierung durchgeführt werden. Sie bilden 
den Grundbedarf an Klassen.

\subsection{Aufbau des Beispiels}
\label{sec:Anwendungsbeispiel:Basis}
Es werden je Datenbanktabelle zwei Klassen ben\"{o}tigt. Zum einen müssen
die Werte der Tabellenzeilen angesprochen werden können, dazu werden
diese als Objekte behandelt. So lassen sich alle Werte mittels 
Gettern und Settern adressieren. Zum anderen wird je eine 
Klasse ben\"{o}tigt, welche sich um den Datenbankzugriff 
k\"{u}mmert und die gew\"{u}nschten Anfragen auf der gesamten Tabelle
durchf\"{u}hrt. 
Im gegebenen Beispiel ist class.Lecture.php und queryLecture.php 
ein solches Klassenp\"{a}rchen, wobei letzteres die Datenbankanfragen 
zur Verf\"{u}gung stellt und abarbeitet. Daf\"{u}r werden die Objekte 
aus der Anwendungslogik auf die entsprechende Zeile in der 
Datenbanktabelle gemappt.

\subsection{Datenbankentitäten}
\label{sec:Anwendungsbeispiel:Datenbankaktivitäten}
Die Klassen für die Datenbankentitäten, stellen die grundlegenden 
Elemente f\"{u}r die 
Datenbankzugriffsklasse bereit, indem die Objektattribute 
entweder mit Standardwerten, \"{u}bergebenen Werten oder Daten
aus der Datenbank initialisiert werden. In der Datenbank sind die Objekte derart
hinterlegt, dass jedes Objekt einer Zeile in der Datenbanktabelle entspricht. Zudem ist je eine 
Funktion, welche alle Werte auf den Standardwert zur\"{u}cksetzen 
kann, eingef\"{u}gt worden. Den gr\"{o}ßten Umfang nehmen die 
Getter und Setter ein, die f\"{u}r jedes Objektattribut, das lesbar und/oder 
modifizierbar ist, angelegt wurden.

\subsection{Abfragen der Datenbank}
\label{sec:Anwendungsbeispiel:Initialisierung}
F\"{u}r lesende oder modifizierende Zugriffe auf die Datenbank 
wird der entsprechenden Methode der queryXyz.php der ben\"{o}tigte 
Datenblock \"{u}bergeben und nach der Anfrage das Ergebnis in 
erwarteter Form zur\"{u}ckgeliefert. Um dies zu erm\"{o}glichen, 
muss f\"{u}r jede denkbare, sinnvolle Anfrage eine Methode mit 
der gew\"{u}nschten Funktionalit\"{a}t vorliegen. In der 
queryLecture.php ist es unter Anderem sinnvoll alle Vorlesungs-Elemente, 
alle Vorlesungen eines bestimmtes Autors oder eines bestimmten Themas 
zur\"{u}ckzugeben.
Zudem wird eine Methode ben\"{o}tigt, um eine Instanz der Zielklasse 
zu erm\"{o}glichen, damit der Zugriff auf die Datenbank serialisierbar 
wird. Im gegebenen Beispiel ist die Erzeugung des R\"{u}ckgabewertes der 
\"{U}bersichtlichkeit halber in einer weiteren Methode gekapselt worden. Dabei werden
Rückgabewerte der Datenbank abgefangen und auf die Objekte gemappt, so dass diese abschließend
zur Verfügung gestellt werden können.

\section{Zusammenfassung und Ausblick}
Unsere Erweiterung der PHP5 Reflection API ermöglichte uns auf äußerst elegante Weise einen WSDL-Generator zu implementieren. Da die Algorithmen zum Ermitteln der Typinformationen sich nicht direkt im WSDL-Generator befanden, konnten wir gleich eine ganze Familie von Web Service Werkzeugen auf Basis der Extended Reflection API entwickeln.
Die Fähigkeiten der Extended Reflection API sind sicherlich für viele weitere PHP Projekte interessant. Der eingeführte Annotation-Mechanismus könnte zudem eine Grundlage für die Nutzung von neuen dynamischen Programmiertechniken wie zum Beispiel aspekt-orientierter Programmierung in PHP sein.

Der WSDL-Generator unterstützt den WSDL 1.1 Standard für document-literal, rpc-literal und rpc-encoded Web Services. %und ist konform zum WS-I Basic Profile 1.1. 
Zur Markierung von Klassen und Methoden als Web Service können Annotationen ähnlich wie in Java~EE und .NET verwendet werden. Zusätzlich werden semantische Informationen aus dem Quelltext in die WSDL-Dokumentation übernommen.
Für document-wrapped Web Services können mit dem Adapter-Generator automatisch Adapter-Klassen generiert werden, die sich transparent um das Wrapping in den SOAP-Nachrichten kümmern.

Die rund 20 weiterführenden WS-*-Spezifikationen im Bereich der Sicherheit, Synchronisation und Sessioning, an denen zur Zeit gearbeitet wird, 
werden zusätzliche Felder für die Header von SOAP-Nachrichten spezifizieren. Um diese Standards in Zukunft mit PHP nutzen zu können entwickelten wir den Extended SOAP Server, der um weitere Handler erweitert werden kann, die als Kette von SOAP-Intermediaries nacheinander eine SOAP-Nachricht bearbeiten.
Auf der Basis des Extended SOAP Servers haben wir das Username-Token-Profile aus dem WS-Security Standard für PHP5 implementiert. Damit ist es Anwendungen, die einen Web Service nutzen, möglich sich beim Dienstanbieter sicher zu authentifizieren.

Als alternative zu Web Services mit komplexen SOAP-Stacks und 
dem damit verbundenen Aufwand, werden die Web Services im 
REST-Stil besonders bei Entwicklern zunehmend
beliebter. Dies hat auf der einen Seite mit dem geringen Toolbedarf
und damit einem geringeren Einstiegsaufwand zu tun und auf der anderen
Seite mit den Vorteilen dieses Architekturstils und der damit verbundenen
Interoperabilität. 
Um dieser Entwicklung Rechnung zu tragen, wurden zusätzliche zu den SOAP-Tools 
entsprechende Werkzeuge zum Erleichtern der Entwicklung von REST Services implementiert.
Diese ermöglichen die automatische Generierung eines REST Servers der die Serviceanfragen 
entgegen nimmt und außerdem bei Bedarf die Authentifikation des Clients über
HTTP Digest durchführt.

Das entwickelte Administrations-Tool bietet schließlich eine einheitliche Oberfläche
um alle Werkzeuge zu konfigurieren und zu starten und damit 
automatisiert SOAP-Server für eine bestehende Anwendung zu generieren.

Trotzdem es Pläne gibt die entwickelten Werkzeuge in einem konkreten Projekt einzusetzen,
lag ein besonderes Augenmerk darauf alle Komponenten so allgemein und wiederverwendbar wie möglich zu gestalten.

% if have a single appendix:
%\appendix[Proof of the Zonklar Equations]
% or
%\appendix  % for no appendix heading
% do not use \section anymore after \appendix, only \section*
% is possibly needed

% use appendices with more than one appendix
% then use \section to start each appendix
% you must declare a \section before using any
% \subsection or using \label (\appendices by itself
% starts a section numbered zero.)
%
% Use this command to get the appendices' numbers in "A", "B" instead of the
% default capitalized Roman numerals ("I", "II", etc.).
% However, the capital letter form may result in awkward subsection numbers
% (such as "A-A"). Capitalized Roman numerals are the default.
%\useRomanappendicesfalse
%
\appendices
\section{Proof of the First Zonklar Equation}
Appendix one text goes here.

% you can choose not to have a title for an appendix
% if you want by leaving the argument blank
\section{}
Appendix two text goes here.

% use section* for acknowledgement
\section*{Acknowledgment}
% optional entry into table of contents (if used)
%\addcontentsline{toc}{section}{Acknowledgment}
The authors would like to thank...

% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section
% NOTE: BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/

% can use a bibliography generated by BibTeX as a .bbl file
% standard IEEE bibliography style from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/supported/IEEEtran/bibtex
%\bibliographystyle{IEEEtran.bst}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
\begin{thebibliography}{99}

\bibitem{SOAP}
\emph{SOAP Version 1.2 specification}, W3C Recommendation \hskip 1em plus
  0.5em minus 0.4em\relax World Wide Web Consortium (W3C), June 24, 2003.
  \newline http://www.w3.org/TR/soap/
  
\bibitem{WSDL}
\emph{Web Services Description Language (WSDL) 1.1}, W3C Note \hskip 1em plus
  0.5em minus 0.4em\relax World Wide Web Consortium (W3C), March 15, 2001.
  \newline http://www.w3.org/TR/wsdl/
  
\bibitem{UDDI}
\emph{Universal Description, Discovery and Integration v3.0.2 (UDDI)} \hskip 1em plus
  0.5em minus 0.4em\relax OASIS, Oktober 19, 2004.
  \newline http://www.oasis-open.org/committees/uddi-spec/doc/spec/v3/uddi-v3.0.2-20041019.htm
  
\bibitem{WebServicePart1}
C.~Hartmann, M.~Sprengel, M.~Perscheid, G.~Gabrysiak, F.~Menge, \emph{Einführung in XML Web Services}, Ausarbeitung zum Seminar Konzepte und Methoden der Web-Programmierung WS2005/06, Hasso-Plattner-Institut für Softwaresystemtechnik, November 2005

\bibitem{WebServicePart2}
S.~Böttner, A.~Meyer, S.~Marr, \emph{Web Service Facade for PHP5}, Ausarbeitung im Seminar Konzepte und Methoden der Web-Programmierung WS2005/06, Hasso-Plattner-Institut für Softwaresystemtechnik, 2006

\bibitem{ibm:soapenc}
Frank Cohen, \emph{Discover SOAP encoding's impact on Web service performance}, März 2003.
http://www-128.ibm.com/developerworks/webservices/library/ws-soapenc/ 

\bibitem{wss:oasis}
\emph {OASIS}: www.oasis-open.org, 2006

\bibitem{wss:usernameTokenProfile}
\emph {Username Token Profil}: http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0.pdf, 2004

\bibitem{wss:designPatterns}
E.~Gamma, R.~Helm, R~Johnson und J.~Vlissides \emph {Design Patterns} Addision-Wesley, 1995

\bibitem{RESTServices}
S.~Marr, \emph{RESTful Web Services}, Ausarbeitung zum ADT-Seminar WS2005/06, Hasso-Plattner-Institut für Softwaresystemtechnik, 2006

\bibitem{RESTTutorial}
TUTORIAL LINK

\bibitem{EnterprisePatterns}
M.~Fowler, D.~Rice, M.~Foemmel, E.~Hieatt, R.~Mee, R.~Stafford, \emph{Patterns of Enterprise Application Architecture}.	Addison Wesley, 2002.

\bibitem{rfc:2818}
E.~Rescorla. RFC 2818: \emph{HTTP Over TLS}. Internet Engineering Task Force, Mai 2000.

\bibitem{rfc:2617}
J.~Franks, P.~Hallam-Baker, J.~Hostetler, S.~Lawrence, P.~Leach, A.~Luotonen, L.~Stewart. RFC 2617: \emph{HTTP Authentication: Basic and Digest Access Authentication}. Internet Engineering Task Force, Juni 1999.


\end{thebibliography}

% biography section
% 
% If you have an EPS/PDF photo (graphicx package needed) extra braces are
% needed around the contents of the optional argument to biography to prevent
% the LaTeX parser from getting confused when it sees the complicated
% \includegraphics command within an optional argument. (You could create
% your own custom macro containing the \includegraphics command to make things
% simpler here.)
%\begin{biography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{mshell}}]{Michael Shell}
% where an .eps filename suffix will be assumed under latex, and a .pdf suffix
% will be assumed for pdflatex; or if you just want to reserve a space for
% a photo:

%\begin{biography}{Michael Shell}
%Biography text here.
%\end{biography}

% if you will not have a photo at all:
%\begin{biographynophoto}{John Doe}
%Biography text here.
%\end{biographynophoto}

% insert where needed to balance the two columns on the last page
%\newpage

%\begin{biographynophoto}{Jane Doe}
%Biography text here.
%\end{biographynophoto}

% You can push biographies down or up by placing
% a \vfill before or after them. The appropriate
% use of \vfill depends on what kind of text is
% on the last page and whether or not the columns
% are being equalized.

%\vfill

% Can be used to pull up biographies so that the bottom of the last one
% is flush with the other column.
%\enlargethispage{-5in}

% that's all folks
\end{document}


