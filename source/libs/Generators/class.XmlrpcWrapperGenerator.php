<?php
//***************************************************************************
//***************************************************************************
//**                                                                       **
//** XmlrpcWrapperGenerator                                                **
//**                                                                       **
//** Project: Web Services Description Generator                           **
//**                                                                       **
//** @author     Matthias Rumpf                                            **
//** @license    www.apache.org/licenses/LICENSE-2.0   Apache License 2.0  **
//**                                                                       **
//***************************************************************************
//***************************************************************************

//***** imports *************************************************************
require_once dirname(__FILE__).'/../../../libs/reflection/class.ExtReflectionClass.php';
require_once dirname(__FILE__).'/../../../libs/reflection/class.ExtReflectionMethod.php';
require_once dirname(__FILE__).'/../../../libs/misc/class.file.php';

//***** XmlrpcWrapperGenerator *************************************
/**
 * generates wrapper classes for xml-rpc Web Services.
 *
 * The generated classes will register the class methods at the server.
 *
 * @package    libs.generator
 * @author     Matthias Rumpf
 * @license    http://www.apache.org/licenses/LICENSE-2.0   Apache License 2.0
 */
class XmlrpcWrapperGenerator {

    /**
     * @var string
     */
    private $className;

    /**
     * @var string
     */
    private $classFile;

    /**
     * @var string
     */
    private $adapterClassName;

    /**
     * @var string
     */
    private $adapterClass;

    //=======================================================================
    /**
     * generates wrapper classes for xml-rpc Web Services.
     *
     * @param string $className name of the class
     * @param ExtReflectionMethod[] $methods array of ExtReflectionMethod objects
     * @param string $adapterClassName name of the generated class
     */
    public function __construct($className, $methods = NULL, $adapterClassName = '') {
        if (empty($className)) {
            throw new Exeption('Argument className was empty.');
        } else {
            $this->className = $className;
        }

        if (!class_exists($className)) {
            throw new Exception('Class not found '.$className);
        }

        $myExtReflectionClass = new ExtReflectionClass($this->className);

        $this->classFile = $myExtReflectionClass->getFileName();

        if ($methods == NULL) {
            $methods = $myExtReflectionClass->getMethods();
        }
        if (empty($adapterClassName)) {
            $this->adapterClassName = $this->generateWrapperClassName($this->className);
        } else {
            $this->adapterClassName = $adapterClassName;
        }
        $gen = '/**' . "\n";
        $gen.= ' * auto-generated xml-wrapper class for class `' . $this->className . "'\n";
        $gen.= ' *' . "\n";
        $gen.= ' * The class will make the unwrapping arguments and the' . "\n";
        $gen.= ' * wrapping of return values.' . "\n";
        $gen.= ' *' . "\n";
        $gen.= ' * generated by XmlrpcWrapperGenerator' . "\n";
        $gen.= ' */' . "\n";
        $gen.= 'class ' . $this->adapterClassName . ' {' . "\n";
        $gen.= '' . "\n";
        $gen.= '    /**' . "\n";
        $gen.= '     * @var '  . $this->className . "\n";
        $gen.= '     */' . "\n";
        $gen.= '    private $target;' . "\n";
        $gen.= '' . "\n";
        $gen.= '    /**' . "\n";
        $gen.= '     * @var xmlrpc_server' . "\n";
        $gen.= '     */' . "\n";
        $gen.= '    private $_rpcServer;' . "\n";
        $gen.= '' . "\n";
        $gen.= '    /**' . "\n";
        $gen.= '     * @param xmlrpc_server $rpcServer' . "\n";
        $gen.= '     * @param '  . $this->className . ' $target' . "\n";
        $gen.= '     */' . "\n";
        $gen.= '    public function __construct($rpcServer, $target = null) {' . "\n";
        $gen.= '        $this->_rpcServer = $rpcServer;' . "\n";
        $gen.= '        $methods = get_class_methods($this);' . "\n";
        $gen.= '        foreach ($methods as $method) {' . "\n";
        $gen.= '            if (substr($method,0,1) != "_") {' . "\n";
        $gen.= '                xmlrpc_server_register_method($rpcServer, get_class($this) . "." . $method, array(&$this, $method));' . "\n";
        $gen.= '            }' . "\n";
        $gen.= '        }' . "\n";
        $gen.= '        if (empty($target)) {' . "\n";
        $gen.= '            $this->target = new ' . $this->className . '();' . "\n";
        $gen.= '        } else {' . "\n";
        $gen.= '            $this->target = $target;' . "\n";
        $gen.= '        }' . "\n";
        $gen.= '    }' . "\n";
        $gen.= '' . "\n";
        $gen.= '' . "\n";
        foreach ($methods as $method) {
            if (!$method->isConstructor() and !$method->isDestructor() and !$method->isMagic()) {
                $methodName = $method->getName();
                $params = $method->getParameters();
                $returnType = $method->getReturnType();

                //echo $methodName . "<br>\n";
                $gen.= '    /**' . "\n";
                $gen.= '     * @param string $methodname' . "\n";
                $gen.= '     * @param array $params' . "\n";
                if (!empty($returnType)) {
                    $gen.= '     * @return ' . $returnType->toString() . "\n";
                } else {
                    $gen.= '     * @return mixed' . "\n";
                }
                $gen.= '     */' . "\n";
                $gen.= '    public function ' . $methodName . '($methodname, $params) {' . "\n";

                $gen.= '        return call_user_func_array(array($this->target, "' . $methodName . '"), $params);' . "\n";
                $gen.= '    }' . "\n";
                $gen.= '' . "\n";
            }
        }
        $gen.= '}';
        $this->adapterClass = $gen;
    }

    //=======================================================================
    /**
     * returns the generated php code for the adapter class
     *
     * @return string generated php code for the adapter class
     */
    public function getAdapterClass() {
        return $this->adapterClass;
    }

    //=======================================================================
    /**
     * returns name of the generated adapter class
     *
     * @return string name of the generated adapter class
     */
    public function getAdapterClassName() {
        return $this->adapterClassName;
    }

    //=======================================================================
    /**
     * writes the generated php code for the adapter class into a file
     *
     * @param string $outputFolder folder for the generated php file
     * @param string $fileName name for the generated php file
     * @param boolean $requireDependingClass if true add a require statement
     * @return string path to generated file
     */
    public function saveToFile($outputFolder, $fileName = '', $requireDependingClass = true) {
        if (empty($fileName)) {
            $fileName = $this->generateClassFileName($this->adapterClassName);
        }
        $path = $outputFolder . '/' . $fileName;

        if ($requireDependingClass) {
            $file = File::absolutePathToRelativePath($outputFolder, $this->classFile);
            $req = 'require_once(\''.$file.'\');'."\n\n";
        }
        else {
            $req = '';
        }

        file_put_contents($path, "<?php\n" .$req. $this->adapterClass . "\n?>\n");
        return $path;
    }

    //=======================================================================
    /**
     * generates a name for an adapter class based on the name of the original class
     *
     * @param string $classname name of the original class
     * @return string filename for an adapter class
     */
    public static function generateWrapperClassName($classname) {
        return $classname . 'Wrap';
    }

    //=======================================================================
    /**
     * generates a filename for a class based on the name of the class
     *
     * @param string $classname name of a class
     * @return string filename for the class
     */
    public static function generateClassFileName($classname) {
        return 'class.' . $classname . '.php';
    }
}
